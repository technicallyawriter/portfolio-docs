= Hugo

image:icons/hugo.png[Hugo logo,50,50]

Hugo is a fast and powerful static site generator for writing in plain text. Don't let the simplicity of plain text fool you, though. Hugo has a high ceiling for configuration, since it leverages and extends the Go programming language. This software's main strengths are its templating and ability to parse content for xref:#_shortcodes[shortcodes] and xref:#_.Getpage_method[methods].

And since Hugo is open source, I can experiment with it for free in personal projects, if I choose. This is a huge advantage compared to pricey proprietary tools like Flare.

== Plain text

Hugo was my first step away from Flare and into the world of plain text static site generators. With plain text, your source code is much easier to read. This makes aspects of version control, like comparing diffs and merging branches, much less complex.

=== AsciiDoc woes

My time with Hugo taught me a hard lesson about AsciiDoc support, though. While Hugo supports AsciiDoc, it requires additional configuration to run somewhat smoothly.^[link:https://blog.arkey.fr/2020/04/23/tackling-hugo-integration-of-asciidoctor[1]]^ ^[link:https://stiobhart.net/2020-04-18-hugo-asciidoctor[2]]^ Your selected theme must also consider AsciiDoc support (most don't) to take full advantage of CSS rules expecting Markdown. 

This ultimately pushed to me try xref:./antora.adoc[Antora], which natively supports the AsciiDocs syntax.

== Shortcodes

Just as the name suggests, shortcodes use quick and clean syntax to refer to more complex functions. This maintains docs readability without sacrificing complexity. A one-line `{{< shortcode >}}` can run dozens of lines of code behind the scenes. By abstracting away this complexity in a dedicated file, Hugo lets you centralize the management of shortcodes, while keeping them simple to reference and read.

Here's a standard example of a shortcode. It creates a custom alert depending on alert type.

.Dedicated file at layouts/shortcodes/alert.html
[source, go (Hugo templating]]
----
include::example$hugo/alert-shortcode.html[]
----

.Reference this alert shortcode in Markdown file and specify "type"
[source, markdown]
----
include::example$hugo/alert-shortcode-call.html[]
----

== Templates

Since Hugo's templating engine extends the Go programming language, it's robust enough to handle more complex use cases. For example, see the below code block that uses `if` and `elseif` conditional logic to display either a `description`, `summary`, or a default, fall-back value if nothing else is set.

.Complex conditional logic in Hugo template
[source, go (Hugo templating)]
----
include::example$hugo/template-logic.html[]
----

Flexibility is an asset, and the ability to fine-tune templates to handle a variety of scenarios is an advantage with Hugo. Who wants to manage several different templates when one does the trick?

== Front matter

Hugo pages use front matter to set values you can parse and refer to as metadata in a variety of ways. Standard values for front matter are `Title`, `Description`, `Date`, and `Author` for example. You can further define metadata in front matter however best suits your needs. 

My favorite ways to use front matter in Hugo are for content reuse, such as with the xref:#.GetPage_method[.GetPage method] or by grouping content with xref:#_taxonomies[taxonomies].

=== .GetPage method

Reuse content you've already written by grabbing it with the `.GetPage` method in Hugo. A classic example of this is when you want to introduce a feature on release notes already written elsewhere. By storing this description in the feature's front matter, you can grab it with the `.Getpage` method.

.Feature xyz's front matter
----
---
Title: "Feature xyz"
Author: "technicallyawriter"
Description: "Feature xyz is the solution to all your problems..."
----

.Reference existing Feature-xyz description for release notes
[source, markdown]
----
include::example$hugo/front-matter-reuse.html[]
----

=== Taxonomies

What if you want to dynamically group similar content by tag to display on its own page? Hugo makes this straight forward with taxonomy pages. 

First, define a "tags" taxonomy in your `hugo.toml` file like so:

[source, toml]
----
[taxonomies]
  tag = "tags"
----

Then, add whatever tags you'd like to a content page, for example "best practice." Hugo automatically generates a page at `/tags/<tag-name>/` for each tag you define. 

----
[source, markdown]
---
Title: "Feature XYZ"
Author: "technicallyawriter"
Tags: "best practice"
---
----

Finally, update your page template to display a page's tags. Users that click the "best practice" tag are redirected to `/tags/best-practice/`.

[source, Go (Hugo templating)]
----
{{ with .Params.tags }}
    <p>Tags: {{ range . }}<a href="{{ "/tags/" | relLangURL }}{{ . | urlize }}">{{ . }}</a> {{ end }}</p>
{{ end }}
----
