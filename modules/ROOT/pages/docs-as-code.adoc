= Docs-as-code

Modern tech writing has evolved to treat documentation like code in how it's versioned, reviewed, tested, and deployed. Though I began my career managing docs in lengthy Microsoft Word documents that chugged and froze on a daily basis, I quickly learned that delivering high quality documentation at scale meant having high quality tooling and processes. 

Fortunately, there's no need to reinvent the wheel. Treat the docs like code! 

== Git

Whether working alone or on a team, proper version control is a must.

=== Feature branching

As a general rule, [branch]`master` branch should always contain production-ready code. This means that documentation for an upcoming release gets worked in feature branches that are typically scoped at the xref:agile.adoc[Epic or Feature level]. Ideally, tickets within these Epics or Features are worked on their own branch and merged into the respective feature branch once complete.

.Feature branching (simple) 
image::feature-branching-simple.png[Feature branches without release branch]

Branching in this way is more straight-forward the more "agile" a company's release cadence is. In other words, if a company releases a feature once it's complete, the feature branch containing the docs is simply merged to [branch]`main` come release time. However, if a company prefers a longer release runway (_cough_ waterfall! _cough_), I'll create a release branch off [branch]`main` to merge completed feature branches into. 

.Feature branching with a release branch
image::feature-branching-release.png[Feature branches with release branch]

Branching like this makes writing release notes for service packs and hotfixes simple, as these docs are just another feature branch. 

.Feature branching with release and hotfix branches
image::feature-branching-release-hotfix.png[Feature branches with release and hotfix branch]

=== Naming conventions

I prefer to name branches using ticket IDs, for example [branch]`feature/jira-123`, as descriptive names can become confusing, vague, or even inaccurate as development evolves. The associated ticket ID serves as a breadcrumb to the source of truth, in this case a Jira ticket, that contains the most up-to-date information about the feature.

[source,bash]
----
$ git branch

* main
feature/jira-123
feature/jira-456
feature/jira-789
release/v1.1.0
hotfix/v1.0.4
----

This isn't the most alluring naming convention, I'll admit. What is lost in presentation is gained in clarity, in my experience. And sometimes:

[quote,Unix Philosophy]
Clarity is better than cleverness

=== Pull requests

Prior to merging, docs are xref:#_testability[tested] and xref:#_peer_review[peer reviewed] as part of a Pull Request (SME review should already be completed before opening PR). Depending on the DevOps setup for docs, a [branch]`feature` or [branch]`dev` branch can be deployed to a staging environment and shared with internal shareholders prior to the release.

== Content reuse

Tech writers can benefit from the coding concept of modular programming, where code is separated depending on the purpose it serves. Then, because segments of code exist independently, they are reused whenever a particular purpose is needed. For documentation, why write something three or four times when you can write it once and reuse it? Doing so creates consistenty for readers and makes docs easier to manage. While I don't advocate for the rigidity of the DITA specification (modularity can be a double-edged sword), I appreciate how content reuse strategies encourage you to write more flexibly, efficiently, and with a clear scope in mind.

Content reuse goes by different names depending on the software I'm using, but the concept remains the same throughout. Here are a few examples from my professional experience. 

=== Examples depending on software

In *MadCap Flare*, I can use a snippet to remind users where they can view their own user permissions. This is helpful when certain permissions are listed as a prerequisite for a task. If this location changes, for example, I only need to update the snippet.

[source,xml]
----
<MadCap:snippetBlock src="../Resources/Snippets/User/ViewPermissions.flsnp" />
----

In *Hugo*, I can create a custom shortcode that holds a feature's "short description" to use both in feature docs and as a release notes blurb.

[source,markdown]
----
{{% feature-xyz-short-desc %}}
----

When writing with AsciiDoc in *Antora*, I can use the `include::` directive to display source code from a file, rathre than copying and pasting it on the page. If I want to reuse this example elsewhere and the example code is updated, all reference to it update automatically.

[source,asciidoc]
----
\include::example$feature-xyz.php[]
----

=== Topic typing

Another valuable content reuse technique is topic typing. At it's most general, this can mean organizing content into three basic categories: **concept**, **task**, or **reference**. 

* **Concept:** used when introducing or explaining an idea, like the overview of a complex feature.
* **Task:** used when instructing user action, like enabling a feature within a product.
* **Reference:** used when providing a large amount of scannable information, like tabular data about compatibility.

Dedicating a page to a specific content type might be enough modularity for you. If desired, you can take topic typing further and make each piece of content within a page more modular. For example:

[source,asciidoc]
----
= Topic xyz

include::topic-xyz-intro.adoc
include::topic-xyz-prerequities.adoc
include::concept-x.adoc
include::concept-y.adoc
include::concept-z.adoc
----

Regardless of how granular you go, decide what's included in each topic and implement a template for each to display information consistently. This consistency makes content reuse easier, as the purpose of each section is narrowly scoped, so you can plug-and-play content as needed.

Structuring content for reuse is easier to do from the start but not _everything_ needs to be reused. Discuss with your team (or yourself) to determine how modular your docs should be.

== Reviews 

Docs are best when they're collaborative. And the most fruitful collaboration often takes the form of reviews.

Tech writers usually aren't the expert on the subject they're writing--for this, there's xref:#_subject_matter_expert_sme_review[Subject Matter Expert (SME) review]. And authors usually aren't the best editors of their own work--for this, there's xref:#_peer_review[peer review].

plain text via GitHub PRs or as Word docs in SharePoint with track changes on.

=== Subject Matter Expert (SME) review
The tightest feedback loop should be between a SME and technical writer. This review ensures technical accuracy, proper order of operations, and prerequisites. This review can be completed prior to or as part of a GitHub Pull Request.

=== Peer review
Once the SME review is complete, other tech writers can evaluate the documentation for style guide adherence, proper information architecture, consistency in tone, grammar, and usage. This review should be completed as part of a GitHub Pull Request.

=== Feature review
Once a feature is nearing **feature complete** status, a final review considering the opinion of key stakeholders (Product Management, Engineering, Professional Services, Support) should occur. This review will take into account higher-level feedback from a wider audience and serve as a jumping off point for training.

== Testability

The author can test at any time, but it's also a good idea to test again during peer review. Validating against style guides and readability. On a team, peer review from other tech writers has the advantage of unfamiliar eyes. This is true for editing as well as "testing" the documentation with someone who's unfamiliar with the content. Sometimes a paragraph makes sense to someone if they already understand the content. This is often not the position of the audience reading user documentation. Distance like this helps actually helps tech writers do their jobs more effectively.

Test against acceptance criteria (these need to be clear, have audience in mind, etc.). Give good and bad example of AC. 

vale (style guides and readability metrics) - is a rule unwarranted? add it to the exceptions list or remove it (does this get overwritten again by `vale sync`?).
